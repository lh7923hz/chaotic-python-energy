================================================================================
ðŸ´â€â˜ ï¸ PIRATE GAMES - COMPLETE TUTORIAL
================================================================================

This tutorial explains both pirate games: the 2D top-down naval battle and
the 3D island explorer. You'll learn how each works and how to build games
like these yourself!

================================================================================
TABLE OF CONTENTS
================================================================================

PART 1: 2D GAME (pirate-battles-2d)
  1.1 - Top-Down View Concepts
  1.2 - Rotation and Angle-Based Movement
  1.3 - Ship Physics (Momentum & Turning)
  1.4 - Projectiles (Cannonballs)
  1.5 - Simple AI for Enemy Ships
  1.6 - Collision Detection

PART 2: 3D GAME (pirate-island-3d)
  2.1 - Understanding 3D Space
  2.2 - First-Person Controller
  2.3 - 3D Entities and Models
  2.4 - Lighting and Environment
  2.5 - 3D Collision and Physics
  2.6 - Camera Control

PART 3: Comparing 2D vs 3D
PART 4: Using the Pirate-Den 3D Models
PART 5: Project Ideas

================================================================================
PART 1: 2D GAME (pirate-battles-2d)
================================================================================

1.1 - TOP-DOWN VIEW CONCEPTS
----------------------------------------

In a top-down game, you look DOWN at the game world from above, like looking
at a map.

Coordinate System:
  - X axis: Left (-) to Right (+)
  - Y axis: Top (-) to Bottom (+)  â† Note: Y increases downward!
  
  (0,0)          X increases â†’
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                         â”‚
    â”‚      Your Ship          â”‚
    â”‚         â–²               â”‚
    â”‚                         â”‚
    â”‚                         â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Y increases â†“

The camera never moves - it's fixed looking down at the entire play area.

1.2 - ROTATION AND ANGLE-BASED MOVEMENT
----------------------------------------

Unlike the platformer where you move left/right, ships ROTATE and move forward.

Angles in Our Game:
  - Measured in DEGREES (0 to 360)
  - 0Â° = pointing RIGHT â†’
  - 90Â° = pointing UP â†‘
  - 180Â° = pointing LEFT â†
  - 270Â° = pointing DOWN â†“

Converting Angle to Direction:
```python
import math

# Ship's angle
angle = 45  # 45 degrees

# Convert to radians (math functions use radians)
angle_rad = math.radians(angle)

# Calculate movement direction
move_x = math.cos(angle_rad)  # Horizontal component
move_y = -math.sin(angle_rad)  # Vertical (negative because Y is down)

# Move the ship
new_x = ship.x + move_x * speed
new_y = ship.y + move_y * speed
```

Why Trigonometry?
  - cos(angle) = horizontal direction
  - sin(angle) = vertical direction
  - Together they make a "unit vector" (direction with length 1)

Example Angles:
  angle = 0Â°   â†’ cos(0) = 1,  sin(0) = 0   â†’ Move RIGHT
  angle = 90Â°  â†’ cos(90) = 0, sin(90) = 1  â†’ Move UP
  angle = 180Â° â†’ cos(180) = -1, sin(180) = 0 â†’ Move LEFT
  angle = 270Â° â†’ cos(270) = 0, sin(270) = -1 â†’ Move DOWN

1.3 - SHIP PHYSICS (Momentum & Turning)
----------------------------------------

Real ships don't stop instantly - they have MOMENTUM!

Our Physics System:
```python
class PlayerShip:
    def __init__(self):
        self.angle = 0          # Direction facing
        self.speed = 0          # Current speed
        self.max_speed = 4      # Top speed
        self.acceleration = 0.2 # How fast we speed up
        self.turn_speed = 3     # How fast we turn
```

Turning:
```python
# Turn left
if keys[LEFT_KEY]:
    self.angle += self.turn_speed  # Increase angle
    
# Turn right
if keys[RIGHT_KEY]:
    self.angle -= self.turn_speed  # Decrease angle
```

Forward Movement:
```python
# Speed up
if keys[FORWARD_KEY]:
    self.speed = min(self.speed + self.acceleration, self.max_speed)
    # min() prevents going over max_speed

# Slow down (natural friction)
else:
    if self.speed > 0:
        self.speed -= self.acceleration / 2
        # Gradually slow down
```

This creates realistic movement:
  - Ships take time to reach full speed
  - Ships drift when you stop accelerating
  - Wide turning circles (can't turn on a dime!)

1.4 - PROJECTILES (Cannonballs)
----------------------------------------

Cannonballs are objects that:
  1. Spawn in front of the ship
  2. Move in the direction the ship was facing
  3. Travel in a straight line
  4. Check for collisions

Creating a Cannonball:
```python
def fire(self):
    # Calculate spawn position (in front of ship)
    angle_rad = math.radians(self.angle)
    offset = 40  # Distance in front of ship
    
    cannon_x = self.x + math.cos(angle_rad) * offset
    cannon_y = self.y - math.sin(angle_rad) * offset
    
    # Create cannonball moving in ship's direction
    return Cannonball(cannon_x, cannon_y, self.angle)
```

Cannonball Movement:
```python
class Cannonball:
    def __init__(self, x, y, angle):
        self.x = x
        self.y = y
        self.angle = angle
        self.speed = 8  # Faster than ships
    
    def update(self):
        # Move in the direction it was fired
        angle_rad = math.radians(self.angle)
        self.x += math.cos(angle_rad) * self.speed
        self.y -= math.sin(angle_rad) * self.speed
```

1.5 - SIMPLE AI FOR ENEMY SHIPS
----------------------------------------

Our enemy ships use basic patrol behavior:

AI Logic:
```python
class EnemyShip:
    def __init__(self):
        self.target_angle = random.randint(0, 360)
        self.patrol_timer = 0
    
    def update(self):
        # Change direction every 2 seconds
        self.patrol_timer += 1
        if self.patrol_timer > 120:  # 120 frames at 60 FPS = 2 seconds
            self.target_angle = random.randint(0, 360)
            self.patrol_timer = 0
        
        # Smoothly turn towards target angle
        if self.angle != self.target_angle:
            # Turn gradually (not instant)
            self.angle += 2  # or -2, depending on which way is shorter
        
        # Move forward
        self.move_forward()
        
        # Fire occasionally
        if random.randint(0, 100) < 2:  # 2% chance each frame
            self.fire()
```

This creates believable enemy behavior:
  - Patrols in different directions
  - Doesn't just chase player (too easy!)
  - Fires cannons occasionally
  - Turns away from islands

1.6 - COLLISION DETECTION
----------------------------------------

Two Types of Collisions:

A) Point-Circle Collision (Cannonball hitting ship):
```python
def check_collision(point_x, point_y, circle_x, circle_y, radius):
    # Calculate distance between point and circle center
    distance = math.sqrt((point_x - circle_x)**2 + (point_y - circle_y)**2)
    
    # Collision if distance is less than radius
    return distance < radius
```

B) Circle-Circle Collision (Ship hitting island):
```python
def check_circle_collision(x1, y1, radius1, x2, y2, radius2):
    distance = math.sqrt((x1 - x2)**2 + (y1 - y2)**2)
    return distance < (radius1 + radius2)
```

Why It Works:
  If distance between centers < sum of radii, they overlap!
  
    â•­â”€â”€Oâ”€â”€â•®     â•­â”€â”€Oâ”€â”€â•®
    â”‚  1  â”‚     â”‚  2  â”‚    distance < r1 + r2  â†’ Collision!
    â•°â”€â”€â”€â”€â”€â•¯     â•°â”€â”€â”€â”€â”€â•¯

================================================================================
PART 2: 3D GAME (pirate-island-3d)
================================================================================

2.1 - UNDERSTANDING 3D SPACE
----------------------------------------

3D adds a THIRD dimension: depth!

Coordinate System:
  - X axis: Left (-) to Right (+)
  - Y axis: Down (-) to Up (+)      â† Note: Y is now UP!
  - Z axis: Far (-) to Near (+)     â† New dimension!

Visualization:
         Y (up)
         â†‘
         â”‚
         â”‚
         â””â”€â”€â”€â”€â†’ X (right)
        â•±
       â•±
      â†™ Z (forward, towards camera)

Position in 3D:
```python
# A treasure chest position
position = (5, 2, 10)
#           â†‘  â†‘  â†‘
#           â”‚  â”‚  â””â”€ Z: 10 units in front
#           â”‚  â””â”€â”€â”€â”€ Y: 2 units high
#           â””â”€â”€â”€â”€â”€â”€â”€ X: 5 units right of center
```

2.2 - FIRST-PERSON CONTROLLER
----------------------------------------

In first-person, YOU ARE the camera!

FirstPersonController (from Ursina):
```python
player = FirstPersonController(
    position=(0, 2, -10),  # Start position (x, y, z)
    speed=5,               # Movement speed
    jump_height=2         # How high you jump
)
```

What It Does:
  - WASD: Moves in 4 directions
  - Mouse: Rotates camera (looks around)
  - SPACE: Jumps
  - Automatic gravity
  - Automatic collision with objects

Movement in 3D:
```python
# Forward: Move in the direction camera is facing
forward_direction = player.forward
new_position = player.position + forward_direction * speed

# Backward: Opposite direction
backward_direction = -player.forward
new_position = player.position + backward_direction * speed

# Left/Right: Perpendicular to forward
right_direction = player.right
left_direction = -player.right
```

2.3 - 3D ENTITIES AND MODELS
----------------------------------------

Everything in 3D is an "Entity" - an object in 3D space.

Creating a Basic Entity:
```python
cube = Entity(
    model='cube',              # Shape (cube, sphere, cylinder, etc.)
    color=color.red,           # Color
    position=(0, 0, 0),        # Location in 3D space
    rotation=(0, 0, 0),        # Rotation on X, Y, Z axes
    scale=(1, 1, 1),           # Size (x, y, z)
    collider='box'             # Collision shape
)
```

Common Models:
  - 'cube': Box/rectangular solid
  - 'sphere': Ball
  - 'cylinder': Tube/column
  - 'plane': Flat surface
  - 'quad': Single flat rectangle

Scale in 3D:
```python
# Uniform scale (same in all directions)
entity.scale = 2  # Twice as big

# Non-uniform scale
entity.scale = (2, 1, 3)
#               â†‘  â†‘  â†‘
#         2x wide, 1x tall, 3x deep
```

Rotation:
```python
# Rotate 45 degrees around Y axis (spinning like a top)
entity.rotation_y = 45

# Continuous rotation (in update loop)
entity.rotation_y += 50 * time.dt  # 50 degrees per second
```

2.4 - LIGHTING AND ENVIRONMENT
----------------------------------------

3D needs lights to see! Without lights, everything is dark.

Types of Lights:

A) Directional Light (The Sun):
```python
sun = DirectionalLight(
    y=2,              # Position high up
    z=3,              # Position back
    shadows=True,     # Cast shadows
    rotation=(45, -45, 45)  # Angle of sunlight
)
```

B) Ambient Light (General brightness):
```python
ambient = AmbientLight(
    color=color.rgba(255, 255, 255, 0.3)  # White light, 30% brightness
)
```

Sky:
```python
# Simple colored sky
Sky(color=color.rgb(135, 206, 250))  # Sky blue

# Or image-based sky
Sky(texture='sky_sunset')
```

Environment Tips:
  - Always have ambient light (or everything is too dark)
  - Use directional light for main lighting
  - Sky color affects the mood
  - Fog adds atmosphere (not in our game, but possible!)

2.5 - 3D COLLISION AND PHYSICS
----------------------------------------

Collision in 3D is similar to 2D, but with an extra dimension!

Distance in 3D:
```python
import math

def distance_3d(pos1, pos2):
    dx = pos2.x - pos1.x
    dy = pos2.y - pos1.y
    dz = pos2.z - pos1.z
    
    return math.sqrt(dx**2 + dy**2 + dz**2)
```

Collision Types:

A) Box Collider:
```python
entity = Entity(
    model='cube',
    collider='box'  # Rectangular collision
)
```

B) Sphere Collider:
```python
entity = Entity(
    model='sphere',
    collider='sphere'  # Circular/spherical collision
)
```

C) Mesh Collider (exact shape):
```python
entity = Entity(
    model='complex_model.obj',
    collider='mesh'  # Follows exact model shape (expensive!)
)
```

Checking Collision:
```python
# Ursina's built-in method
if player.intersects(other_entity).hit:
    print("Collision!")

# Or manual distance check
distance = (player.position - treasure.position).length()
if distance < 2:
    print("Close enough to collect!")
```

2.6 - CAMERA CONTROL
----------------------------------------

The camera IS your eyes in 3D!

Camera Position:
```python
# The camera is attached to the player
# So player.position = camera.position

# Look at a specific point
camera.look_at(treasure.position)

# Camera follows player automatically with FirstPersonController
```

Field of View (FOV):
```python
camera.fov = 90  # Wide angle (default is 90)
camera.fov = 60  # Narrow angle (zoomed in)
```

Mouse Lock:
```python
mouse.locked = True   # Mouse controls camera
mouse.locked = False  # Mouse visible, can click UI
```

================================================================================
PART 3: COMPARING 2D vs 3D
================================================================================

Concept Comparison:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Aspect       â”‚ 2D                  â”‚ 3D                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Coordinates  â”‚ X, Y (2 axes)       â”‚ X, Y, Z (3 axes)    â”‚
â”‚ Camera       â”‚ Fixed top-down      â”‚ Free-moving         â”‚
â”‚ Movement     â”‚ Angle + speed       â”‚ Direction vectors   â”‚
â”‚ Rotation     â”‚ Single angle (0-360)â”‚ 3 angles (X,Y,Z)    â”‚
â”‚ Collision    â”‚ Circle/Rectangle    â”‚ Sphere/Box/Mesh     â”‚
â”‚ Rendering    â”‚ Draw shapes/sprites â”‚ 3D models+lighting  â”‚
â”‚ Complexity   â”‚ Simpler math        â”‚ More complex        â”‚
â”‚ Performance  â”‚ Faster              â”‚ Slower (more calcs) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

When to Use Each:

2D is better for:
  - Top-down games (strategy, racing)
  - Side-scrollers (platformers)
  - Simple mechanics
  - Mobile games
  - Retro style
  - Faster development

3D is better for:
  - First/third person games
  - Exploration
  - Realistic simulation
  - Modern AAA style
  - VR games
  - When depth matters

Many successful games use 2D! It's not "worse" - just different.

================================================================================
PART 4: USING THE PIRATE-DEN 3D MODELS
================================================================================

Your pirate-den folder has 66 professional 3D models!

File Formats Available:
  - GLB: Best for Ursina (compact, includes textures)
  - OBJ: Universal format (separate texture files)
  - FBX: For Unity/Unreal/Blender

Loading a Model in Ursina:
```python
# Path to your model
model_path = '../pirate-den/Models/GLB format/ship-large.glb'

# Create entity with the model
pirate_ship = Entity(
    model=model_path,
    position=(10, 0, 10),
    scale=2,
    rotation_y=45,
    collider='box'
)
```

Animating Models:
```python
# Some models have animations (like the chest opening)
# Check the Overview.html to see which have animations

animated_chest = Entity(
    model='../pirate-den/Models/GLB format/chest.glb',
    position=(0, 0, 0)
)

# Play animation (if model has it)
# animated_chest.play_animation('open')  # Depends on model
```

Textures:
```python
# The colormap.png is shared by all models
# GLB files include it automatically
# For OBJ, you need to load it:

entity = Entity(
    model='../pirate-den/Models/OBJ format/ship-large.obj',
    texture='../pirate-den/Models/Textures/colormap.png'
)
```

Recommended Models to Try:

Easy to Use:
  - barrel, crate, bottle: Simple props
  - palm-straight: Trees
  - rocks-a/b/c: Decorations
  - platform: Walkable surfaces

Medium Complexity:
  - boat-row-small: Small boat
  - cannon: Interactive object
  - chest: Treasure (has animation!)
  - tower-complete-small: Building

Advanced:
  - ship-large: Full pirate ship
  - ship-wreck: Damaged ship
  - structure-platform-dock: Large dock

================================================================================
PART 5: PROJECT IDEAS
================================================================================

Build on What You've Learned!

2D Project Ideas:
  1. Racing Game: Ships race around a track
  2. Territory Control: Capture islands
  3. Multiplayer Battles: 2 players, one keyboard
  4. Survival Mode: Endless waves of enemies
  5. Trade Simulation: Buy/sell cargo at ports

3D Project Ideas:
  1. Pirate Town: Walk around a village
  2. Ship Interior: Explore inside a ship
  3. Cave Explorer: Find treasure in caves
  4. Multiplayer Island: Multiple players explore
  5. Building System: Place your own structures

Hybrid Ideas:
  1. Start in 3D on island, switch to 2D naval battles
  2. Strategic map (2D) + Battle view (3D)
  3. Use 2D for planning, 3D for execution

Challenge Features:
  - Save/load game state
  - Procedural island generation
  - Weather system (storms affect movement)
  - Reputation system (friendly/enemy ports)
  - Crew management
  - Realistic wind physics
  - Treasure maps with X marks the spot
  - Day/night cycle
  - Customizable ship upgrades

================================================================================
KEY TAKEAWAYS
================================================================================

2D Top-Down Game:
  âœ“ Uses angles and trigonometry for movement
  âœ“ Ships have momentum and turning radius
  âœ“ Projectiles fly in straight lines
  âœ“ Simple AI can create fun challenge
  âœ“ Circle collision detection is efficient

3D First-Person Game:
  âœ“ Adds depth (Z axis) to movement
  âœ“ Camera is your viewpoint
  âœ“ Entities are objects in 3D space
  âœ“ Lighting is essential
  âœ“ More complex but more immersive

Both Games:
  âœ“ Game loop: Input â†’ Update â†’ Draw
  âœ“ Collision detection prevents overlap
  âœ“ Score/state tracking
  âœ“ Clean code organization

Learning Path:
  1. Master 2D first (simpler concepts)
  2. Then tackle 3D (builds on 2D knowledge)
  3. Experiment and modify
  4. Create your own unique games!

================================================================================
ADDITIONAL RESOURCES
================================================================================

Pygame:
  - Documentation: https://www.pygame.org/docs/
  - Tutorials: https://realpython.com/pygame-a-primer/

Ursina:
  - Documentation: https://www.ursinaengine.org/documentation.html
  - Cheat Sheet: https://www.ursinaengine.org/cheat_sheet.html

Math for Games:
  - Trigonometry basics
  - Vector mathematics
  - Collision algorithms

3D Modeling:
  - Blender (free 3D software)
  - Kenney assets (free game assets)

================================================================================
NOW YOU'RE READY!
================================================================================

You have:
  âœ“ 2D top-down pirate battle game
  âœ“ 3D first-person island explorer
  âœ“ Understanding of both approaches
  âœ“ 66 professional 3D models to use
  âœ“ Knowledge to create your own games

Next steps:
  1. Run both games and play them
  2. Read the code with this tutorial
  3. Make small changes and see what happens
  4. Build something completely new!

Remember: Every game developer started as a beginner. The only way to learn
is to BUILD, BREAK, and FIX things. Don't be afraid to experiment!

Happy coding, Captain! ðŸ´â€â˜ ï¸

================================================================================
END OF TUTORIAL
================================================================================

